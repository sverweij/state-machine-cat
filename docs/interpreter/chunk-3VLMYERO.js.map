{
  "version": 3,
  "sources": ["../../src/render/scjson/make-valid-xml-name.mts", "../../src/render/scjson/make-valid-event-names.mts", "../../src/render/scjson/index.mts"],
  "sourcesContent": ["/*\n * In the XML spec we read: https://www.w3.org/TR/xml/#NT-Name:\n *\n * NameStartChar ::= \":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] |\n *                   [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |\n *                   [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n * NameChar      ::= NameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n * Name          ::= NameStartChar (NameChar)*\n *\n * This means that these characters are forbidden for NameStartChar\n * #xD7, #xF7, #x300 - #x36F, #x37E, #x2000 - #x200B, #x200E - #x206F, #x2190 - #x2BFF, #x2FF0 - #x3000,\n * #xD800 - #xF8FF, #xFDD0 - #xFDEF, #xFFFE - #xFFFF\n */\n\n/* eslint no-control-regex: 0, max-len: 0, no-misleading-character-class: 0 */\nconst NAME_CHAR_FORBIDDEN_RE =\n  /[\\u0000-\\u002C\\u002F\\u003B-\\u0040\\u005B-\\u0060\\u007B-\\u00BF\\u00D7\\u00F7\\u0300-\\u036F\\u037E\\u2000-\\u200B\\u200E-\\u206F\\u2190-\\u2BFF\\u2FF0-\\u3000\\uD800-\\uF8FF\\uFDD0-\\uFDEF\\uFFFE-\\uFFFF]/g;\nconst START_NAME_CHAR_FORBIDDEN_EXTRA_RE =\n  /[-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]/g;\n\nfunction makeValidNameChars(pCandidateNameTail: string): string {\n  return pCandidateNameTail.replace(NAME_CHAR_FORBIDDEN_RE, \"_\");\n}\n\n/**\n * if it's an invalid NameStartChar but a valid NameChar smack a '_' in front of it\n * if it's an invalid NameChar as well - run it through the makeValidNameChars replacer\n */\nfunction makeValidNameStartChar(pCandidateChar: string): string {\n  let lReturnValue = makeValidNameChars(pCandidateChar);\n\n  if (lReturnValue.match(START_NAME_CHAR_FORBIDDEN_EXTRA_RE)) {\n    lReturnValue = `_${pCandidateChar}`;\n  }\n  return lReturnValue;\n}\n\n/**\n * Takes any string and returns a valid XMLName using these rules:\n *\n * If pCandidateName is not empty:\n *   For all characters in pCandidateName:\n *    if it's not a valid NameChar, replace it with '_'\n *   For the first character:\n *     If it's a valid NameChar, but not a valid NameStartChar, add an '_' in front of the pCandidateName\n *\n * If pCandidateName is empty:\n *  return the string '__empty'\n */\nexport default (pCandidateName: string): string => {\n  pCandidateName = pCandidateName || \"\";\n\n  if (pCandidateName.length === 0) {\n    return `__empty`;\n  }\n  return makeValidNameStartChar(pCandidateName[0]).concat(\n    makeValidNameChars(pCandidateName.slice(1)),\n  );\n};\n", "/*\n * In the XML spec we read: https://www.w3.org/TR/xml/#NT-Name:\n *\n * NameStartChar ::= \":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] |\n *                   [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |\n *                   [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n * NameChar      ::= NameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n * Name          ::= NameStartChar (NameChar)*\n *\n * This means that these characters are forbidden for NameStartChar\n * #xD7, #xF7, #x300 - #x36F, #x37E, #x2000 - #x200B, #x200E - #x206F, #x2190 - #x2BFF, #x2FF0 - #x3000,\n * #xD800 - #xF8FF, #xFDD0 - #xFDEF, #xFFFE - #xFFFF\n */\n\n/* eslint no-control-regex: 0, max-len: 0, no-misleading-character-class: 0 */\n//  EVENT_CHAR_FORBIDDEN_RE === forbidden for NameStartChar, except \"-\" and [0-9]\n// The SCXML xsd doesn't seem to mention '*' (\\u002A) as an allowed character. But\n// they _are_ used in event descriptors in the SCXML spec. So we've excluded\n// them from forbidden characters\nconst EVENT_CHAR_FORBIDDEN_RE =\n  /[\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\u0000-\\u0029\\u002B-\\u002C\\u002F\\u003B-\\u0040\\u005B-\\u0060\\u007B-\\u00BF\\u00D7\\u00F7\\u0300-\\u036F\\u037E\\u2000-\\u200B\\u200E-\\u206F\\u2190-\\u2BFF\\u2FF0-\\u3000\\uD800-\\uF8FF\\uFDD0-\\uFDEF\\uFFFE-\\uFFFF]/g;\nconst START_EVENT_CHAR_FORBIDDEN_EXTRA_RE = /[.]/g;\n\nfunction makeValidEventChar(pCandidateEventStringTail: string): string {\n  return pCandidateEventStringTail.replace(EVENT_CHAR_FORBIDDEN_RE, \"_\");\n}\n\nfunction makeValidEventStartChar(pCandidateEventStringStart: string): string {\n  let lReturnValue = makeValidEventChar(pCandidateEventStringStart);\n\n  if (lReturnValue.match(START_EVENT_CHAR_FORBIDDEN_EXTRA_RE)) {\n    lReturnValue = `_${pCandidateEventStringStart}`;\n  }\n  return lReturnValue;\n}\n\nfunction makeValidEventName(pCandidateEventName: string): string {\n  pCandidateEventName = pCandidateEventName.replace(/\\s+/g, \" \").trim();\n\n  return makeValidEventStartChar(pCandidateEventName[0]).concat(\n    makeValidEventChar(pCandidateEventName.slice(1)),\n  );\n}\n/**\n * Takes any string and returns a valid SCXML events string:\n *\n * If pCandidateName is not empty:\n *   For all characters in pCandidateName:\n *    if it's not a valid NameChar, replace it with '_'\n *   For the first character:\n *     If it's a valid NameChar, but not a valid NameStartChar, add an '_' in front of the pCandidateName\n *\n * If pCandidateName is empty:\n *  return the string 'empty'\n * *\n * @returns a valid SCXML events string\n */\nexport default (pCandidateEventNames?: string): string => {\n  const lCandidateEventNames = pCandidateEventNames ?? \"\";\n\n  if (lCandidateEventNames.length === 0) {\n    return \"empty\";\n  }\n\n  return lCandidateEventNames\n    .split(/[\\n\\r]+/)\n    .filter((pCandidateEventName) => pCandidateEventName.length > 0)\n    .map(makeValidEventName)\n    .join(\" \");\n};\n", "/* eslint-disable security/detect-object-injection */\nimport type {\n  ActionTypeType,\n  IActionType,\n  IRenderOptions,\n  IState,\n  IStateMachine,\n  ITransition,\n} from \"types/state-machine-cat.mjs\";\nimport StateMachineModel from \"../../state-machine-model.mjs\";\nimport type {\n  ISCJSONMachine,\n  ISCJSONState,\n  ISCJSONTransition,\n} from \"./scjson.js\";\nimport makeValidXMLName from \"./make-valid-xml-name.mjs\";\nimport makeValidEventNames from \"./make-valid-event-names.mjs\";\n\nconst STATE_TYPE2SCXML_STATE_KIND: Map<string, string> = new Map([\n  [\"regular\", \"state\"],\n  [\"initial\", \"initial\"],\n  [\"final\", \"final\"],\n  [\"terminate\", \"final\"],\n  [\"parallel\", \"parallel\"],\n  [\"history\", \"history\"],\n  [\"deephistory\", \"history\"],\n]);\n\nfunction stateType2SCXMLStateKind(pStateType: string): string {\n  return STATE_TYPE2SCXML_STATE_KIND.get(pStateType) || \"state\";\n}\n\nfunction transformTransition(pTransition: ITransition): ISCJSONTransition {\n  const lReturnValue: ISCJSONTransition = {\n    target: makeValidXMLName(pTransition.to),\n  };\n\n  if (pTransition.event) {\n    lReturnValue.event = makeValidEventNames(pTransition.event);\n  }\n  if (pTransition.cond) {\n    lReturnValue.cond = pTransition.cond;\n  }\n  if (pTransition.action) {\n    lReturnValue.action = pTransition.action;\n  }\n  if (pTransition.type) {\n    lReturnValue.type = pTransition.type;\n  }\n  return lReturnValue;\n}\n\nfunction extractTriggers(\n  pTriggers: IActionType[],\n  pTriggerType: ActionTypeType,\n): string[] {\n  return pTriggers\n    .filter((pTrigger) => pTrigger.type === pTriggerType)\n    .map((pTrigger) => pTrigger.body);\n}\n\nfunction pullOutActionType(\n  pReturnValue: ISCJSONState,\n  pTriggersType: \"onentries\" | \"onexits\",\n  pActions: IActionType[],\n  pActionType: ActionTypeType,\n): void {\n  const lTriggerArray: string[] = extractTriggers(pActions, pActionType);\n\n  if (lTriggerArray.length > 0) {\n    pReturnValue[pTriggersType] = (pReturnValue[pTriggersType] || []).concat(\n      lTriggerArray,\n    );\n  }\n}\n\nfunction transformTriggers(pReturnValue: ISCJSONState, pState: IState): void {\n  if (pState.actions) {\n    pullOutActionType(pReturnValue, \"onentries\", pState.actions, \"entry\");\n    pullOutActionType(pReturnValue, \"onentries\", pState.actions, \"activity\");\n    pullOutActionType(pReturnValue, \"onexits\", pState.actions, \"exit\");\n  }\n}\n\nfunction transformTransitions(\n  pReturnValue: ISCJSONState,\n  pState: IState,\n  pTransitions: ITransition[],\n): void {\n  const lTransitions = pTransitions\n    .filter((pTransition) => pTransition.from === pState.name)\n    .map(transformTransition);\n\n  if (lTransitions.length > 0) {\n    pReturnValue.transitions = lTransitions;\n  }\n}\n\nfunction transformCompositeState(\n  pReturnValue: ISCJSONState,\n  pState: IState,\n  pTransitions: ITransition[],\n): void {\n  if (pState.statemachine) {\n    // recursion, so ...\n    // eslint-disable-next-line no-use-before-define, no-undefined\n    const lRenderedState = render(pState.statemachine, undefined, pTransitions);\n\n    pReturnValue.states = (pReturnValue.states || []).concat(\n      lRenderedState.states,\n    );\n    if (lRenderedState.initial) {\n      pReturnValue.initial = lRenderedState.initial;\n    }\n  }\n}\n\nfunction transformState(pTransitions: ITransition[]) {\n  pTransitions = pTransitions || [];\n\n  return (pState: IState): ISCJSONState => {\n    const lReturnValue: ISCJSONState = {\n      kind: stateType2SCXMLStateKind(pState.type),\n      id: makeValidXMLName(pState.name),\n    };\n\n    if (pState.type === \"deephistory\") {\n      // as 'shallow' is the default anyway, we leave it out\n      lReturnValue.type = \"deep\";\n    }\n\n    transformTriggers(lReturnValue, pState);\n\n    transformTransitions(lReturnValue, pState, pTransitions);\n\n    transformCompositeState(lReturnValue, pState, pTransitions);\n    return lReturnValue;\n  };\n}\n\nfunction findInitialPseudoStateName(\n  pStateMachine: IStateMachine,\n): string | undefined {\n  const lInitial = pStateMachine.states.filter(\n    (pState) => pState.type === \"initial\",\n  );\n\n  if (lInitial.length > 0) {\n    return lInitial[0].name;\n  }\n  // eslint-disable-next-line no-undefined\n  return undefined;\n}\n\nfunction findInitialStateName(\n  pStateMachine: IStateMachine,\n  pInitialPseudoStateName?: string,\n): string | undefined {\n  let lReturnValue = pInitialPseudoStateName;\n\n  if (pInitialPseudoStateName && pStateMachine.transitions) {\n    const lInitialTransitions = pStateMachine.transitions.filter(\n      (pTransition) => pTransition.from === pInitialPseudoStateName,\n    );\n\n    if (lInitialTransitions.length > 0 && !lInitialTransitions[0].action) {\n      lReturnValue = lInitialTransitions[0].to;\n    }\n  }\n  return lReturnValue;\n}\n\nexport default function render(\n  pStateMachine: IStateMachine,\n  _pOptions?: IRenderOptions,\n  pTransitions?: ITransition[],\n): ISCJSONMachine {\n  const lInitialPseudoStateName = findInitialPseudoStateName(pStateMachine);\n  const lInitialStateName = findInitialStateName(\n    pStateMachine,\n    lInitialPseudoStateName,\n  );\n  const lReturnValue: ISCJSONMachine = {\n    states: pStateMachine.states\n      .filter((pState) => {\n        if (\n          lInitialStateName &&\n          lInitialStateName !== lInitialPseudoStateName\n        ) {\n          return pState.type !== \"initial\";\n        }\n        return true;\n      })\n      .map(\n        transformState(\n          pTransitions ||\n            new StateMachineModel(pStateMachine).flattenedTransitions,\n        ),\n      ),\n  };\n\n  if (lInitialStateName) {\n    lReturnValue.initial = makeValidXMLName(lInitialStateName);\n  }\n  return lReturnValue;\n}\n"],
  "mappings": "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",
  "names": ["NAME_CHAR_FORBIDDEN_RE", "START_NAME_CHAR_FORBIDDEN_EXTRA_RE", "makeValidNameChars", "pCandidateNameTail", "makeValidNameStartChar", "pCandidateChar", "lReturnValue", "make_valid_xml_name_default", "pCandidateName", "EVENT_CHAR_FORBIDDEN_RE", "START_EVENT_CHAR_FORBIDDEN_EXTRA_RE", "makeValidEventChar", "pCandidateEventStringTail", "makeValidEventStartChar", "pCandidateEventStringStart", "lReturnValue", "makeValidEventName", "pCandidateEventName", "make_valid_event_names_default", "pCandidateEventNames", "lCandidateEventNames", "STATE_TYPE2SCXML_STATE_KIND", "stateType2SCXMLStateKind", "pStateType", "transformTransition", "pTransition", "lReturnValue", "make_valid_xml_name_default", "make_valid_event_names_default", "extractTriggers", "pTriggers", "pTriggerType", "pTrigger", "pullOutActionType", "pReturnValue", "pTriggersType", "pActions", "pActionType", "lTriggerArray", "transformTriggers", "pState", "transformTransitions", "pTransitions", "lTransitions", "transformCompositeState", "lRenderedState", "render", "transformState", "findInitialPseudoStateName", "pStateMachine", "lInitial", "findInitialStateName", "pInitialPseudoStateName", "lInitialTransitions", "_pOptions", "lInitialPseudoStateName", "lInitialStateName", "StateMachineModel"]
}
