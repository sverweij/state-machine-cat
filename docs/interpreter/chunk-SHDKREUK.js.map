{
  "version": 3,
  "sources": ["../../src/state-machine-model.mts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  IState,\n  IStateMachine,\n  ITransition,\n  StateType,\n} from \"types/state-machine-cat.mjs\";\n\ninterface IFlattenedState extends Omit<IState, \"statemachine\"> {\n  statemachine: boolean;\n  parent: string;\n}\n\n// eslint-disable-next-line complexity\nfunction flattenStatesToMap(\n  pStates: IState[],\n  pMap: Map<string, IFlattenedState>,\n  pParent: string = \"\",\n): void {\n  for (const lState of pStates) {\n    if (lState?.statemachine?.states) {\n      flattenStatesToMap(lState.statemachine.states, pMap, lState.name);\n    }\n  }\n\n  for (const lState of pStates) {\n    pMap.set(lState.name, {\n      name: lState.name,\n      type: lState.type,\n      statemachine: Boolean(lState.statemachine),\n      parent: pParent,\n    });\n  }\n}\n\nfunction flattenTransitions(pStateMachine: IStateMachine): ITransition[] {\n  let lTransitions: ITransition[] = [];\n\n  if (Object.hasOwn(pStateMachine, \"transitions\")) {\n    // @ts-expect-error TS doesn't detect that after the call in the if the\n    // .transitions is guaranteed to exist\n    lTransitions = structuredClone(pStateMachine.transitions);\n  }\n  if (Object.hasOwn(pStateMachine, \"states\")) {\n    for (const lState of pStateMachine.states) {\n      if (lState.statemachine) {\n        lTransitions = lTransitions.concat(\n          flattenTransitions(lState.statemachine),\n        );\n      }\n    }\n  }\n\n  return lTransitions;\n}\n\nexport default class StateMachineModel {\n  readonly #flattenedTransitions: ITransition[];\n  readonly #flattenedStates: Map<string, IFlattenedState>;\n\n  constructor(pStateMachine: IStateMachine) {\n    this.#flattenedStates = new Map();\n    flattenStatesToMap(pStateMachine.states ?? [], this.#flattenedStates);\n    this.#flattenedTransitions = flattenTransitions(pStateMachine);\n  }\n\n  get flattenedTransitions(): ITransition[] {\n    return this.#flattenedTransitions;\n  }\n\n  get flattenedStates(): Map<string, IFlattenedState> {\n    return this.#flattenedStates;\n  }\n\n  findStateByName(pName: string): IFlattenedState | undefined {\n    return this.#flattenedStates.get(pName);\n  }\n\n  findStatesByTypes(pTypes: StateType[]): any[] {\n    return Array.from(this.#flattenedStates.values()).filter((pState) =>\n      pTypes.includes(pState.type),\n    );\n  }\n\n  findExternalSelfTransitions(pStateName: string): ITransition[] {\n    return this.#flattenedTransitions.filter(\n      (pTransition) =>\n        pTransition.from === pStateName &&\n        pTransition.to === pStateName &&\n        pTransition.type !== \"internal\",\n    );\n  }\n\n  findTransitionsByFrom(pFromStateName: string): ITransition[] {\n    return this.#flattenedTransitions.filter(\n      (pTransition) => pTransition.from === pFromStateName,\n    );\n  }\n\n  findTransitionsByTo(pToStateName: string): ITransition[] {\n    return this.#flattenedTransitions.filter(\n      (pTransition) => pTransition.to === pToStateName,\n    );\n  }\n\n  getMaximumTransitionId(): number {\n    return Math.max(...this.#flattenedTransitions.map(({ id }) => id));\n  }\n\n  findTransitionsToSiblings(\n    pStateName: string,\n    pExcludeIds: Set<number>,\n  ): ITransition[] {\n    return this.#flattenedTransitions.filter(\n      (pTransition) =>\n        !pExcludeIds.has(pTransition.id) &&\n        pTransition.from === pStateName &&\n        this.#flattenedStates.get(pTransition.to)?.parent ===\n          this.#flattenedStates.get(pStateName)?.parent,\n    );\n  }\n}\n"],
  "mappings": "AAcA,SAASA,EACPC,EACAC,EACAC,EAAkB,GACZ,CACN,QAAWC,KAAUH,EACfG,GAAQ,cAAc,QACxBJ,EAAmBI,EAAO,aAAa,OAAQF,EAAME,EAAO,IAAI,EAIpE,QAAWA,KAAUH,EACnBC,EAAK,IAAIE,EAAO,KAAM,CACpB,KAAMA,EAAO,KACb,KAAMA,EAAO,KACb,aAAc,EAAQA,EAAO,aAC7B,OAAQD,CACV,CAAC,CAEL,CAEA,SAASE,EAAmBC,EAA6C,CACvE,IAAIC,EAA8B,CAAC,EAOnC,GALI,OAAO,OAAOD,EAAe,aAAa,IAG5CC,EAAe,gBAAgBD,EAAc,WAAW,GAEtD,OAAO,OAAOA,EAAe,QAAQ,EACvC,QAAWF,KAAUE,EAAc,OAC7BF,EAAO,eACTG,EAAeA,EAAa,OAC1BF,EAAmBD,EAAO,YAAY,CACxC,GAKN,OAAOG,CACT,CAEA,IAAqBC,EAArB,KAAuC,CAC5BC,GACAC,GAET,YAAYJ,EAA8B,CACxC,KAAKI,GAAmB,IAAI,IAC5BV,EAAmBM,EAAc,QAAU,CAAC,EAAG,KAAKI,EAAgB,EACpE,KAAKD,GAAwBJ,EAAmBC,CAAa,CAC/D,CAEA,IAAI,sBAAsC,CACxC,OAAO,KAAKG,EACd,CAEA,IAAI,iBAAgD,CAClD,OAAO,KAAKC,EACd,CAEA,gBAAgBC,EAA4C,CAC1D,OAAO,KAAKD,GAAiB,IAAIC,CAAK,CACxC,CAEA,kBAAkBC,EAA4B,CAC5C,OAAO,MAAM,KAAK,KAAKF,GAAiB,OAAO,CAAC,EAAE,OAAQG,GACxDD,EAAO,SAASC,EAAO,IAAI,CAC7B,CACF,CAEA,4BAA4BC,EAAmC,CAC7D,OAAO,KAAKL,GAAsB,OAC/BM,GACCA,EAAY,OAASD,GACrBC,EAAY,KAAOD,GACnBC,EAAY,OAAS,UACzB,CACF,CAEA,sBAAsBC,EAAuC,CAC3D,OAAO,KAAKP,GAAsB,OAC/BM,GAAgBA,EAAY,OAASC,CACxC,CACF,CAEA,oBAAoBC,EAAqC,CACvD,OAAO,KAAKR,GAAsB,OAC/BM,GAAgBA,EAAY,KAAOE,CACtC,CACF,CAEA,wBAAiC,CAC/B,OAAO,KAAK,IAAI,GAAG,KAAKR,GAAsB,IAAI,CAAC,CAAE,GAAAS,CAAG,IAAMA,CAAE,CAAC,CACnE,CAEA,0BACEJ,EACAK,EACe,CACf,OAAO,KAAKV,GAAsB,OAC/BM,GACC,CAACI,EAAY,IAAIJ,EAAY,EAAE,GAC/BA,EAAY,OAASD,GACrB,KAAKJ,GAAiB,IAAIK,EAAY,EAAE,GAAG,SACzC,KAAKL,GAAiB,IAAII,CAAU,GAAG,MAC7C,CACF,CACF",
  "names": ["flattenStatesToMap", "pStates", "pMap", "pParent", "lState", "flattenTransitions", "pStateMachine", "lTransitions", "StateMachineModel", "#flattenedTransitions", "#flattenedStates", "pName", "pTypes", "pState", "pStateName", "pTransition", "pFromStateName", "pToStateName", "id", "pExcludeIds"]
}
