{
  "version": 3,
  "sources": ["../../src/transform/desugar.mts"],
  "sourcesContent": ["/* eslint-disable security/detect-object-injection */\nimport type {\n  IStateMachine,\n  ITransition,\n  StateType,\n} from \"types/state-machine-cat.mjs\";\nimport StateMachineModel from \"../state-machine-model.mjs\";\nimport { Counter } from \"../counter.mjs\";\nimport { formatLabel } from \"./utl.mjs\";\n\ntype ITransitionMap = {\n  [stateName: string]: ITransition[];\n};\n\nfunction fuseTransitionAttribute(\n  pIncomingThing: string | undefined,\n  pOutgoingThing: string,\n  pJoinChar: string,\n): string {\n  return pIncomingThing\n    ? `${pIncomingThing}${pJoinChar}${pOutgoingThing}`\n    : pOutgoingThing;\n}\n\nfunction fuseIncomingToOutgoing(\n  pIncomingTransition: ITransition,\n  pOutgoingTransition: ITransition,\n  pCounter: Counter,\n): ITransition {\n  // in:\n  // a => ]: event [condition]/ action;\n  // ] => b: event_to_b [condition_to_b]/ action to b;\n  //\n  // out:\n  // a => b: event [condition]/ action\\naction to b;\n  //\n  // events and conditions are illegal on transitions outgoing\n  // from forks, so we ignore them\n  const lReturnValue = {\n    ...pIncomingTransition,\n    ...pOutgoingTransition,\n    from: pIncomingTransition.from,\n    to: pOutgoingTransition.to,\n    id: pCounter.next(),\n  };\n\n  if (pOutgoingTransition.action) {\n    lReturnValue.action = fuseTransitionAttribute(\n      pIncomingTransition.action,\n      pOutgoingTransition.action,\n      \"\\n\",\n    );\n  }\n  if (lReturnValue.event || lReturnValue.cond || lReturnValue.action) {\n    lReturnValue.label = formatLabel(\n      lReturnValue.event,\n      lReturnValue.cond,\n      lReturnValue.action,\n    );\n  }\n\n  return lReturnValue;\n}\n\n// eslint-disable-next-line complexity\nfunction fuseTransitions(\n  pTransitions: ITransition[],\n  pPseudoStateNames: string[],\n  pOutgoingTransitionMap: ITransitionMap,\n  pCounter: Counter,\n): ITransition[] {\n  const lResult: ITransition[] = [];\n\n  for (const lTransition of pTransitions) {\n    let lAdded = false;\n    for (const lStateName of pPseudoStateNames) {\n      if (lStateName === lTransition.to && pOutgoingTransitionMap[lStateName]) {\n        // eslint-disable-next-line max-depth\n        for (const lOutgoing of pOutgoingTransitionMap[lStateName]) {\n          lResult.push(\n            fuseIncomingToOutgoing(lTransition, lOutgoing, pCounter),\n          );\n        }\n        lAdded = true;\n      }\n    }\n    if (!lAdded) {\n      lResult.push(lTransition);\n    }\n  }\n\n  return lResult;\n}\n\nfunction deSugarPseudoStates(\n  pMachine: IStateMachine,\n  pPseudoStateNames: string[],\n  pOutgoingTransitionMap: ITransitionMap,\n  pCounter: Counter,\n): IStateMachine {\n  const lMachine = structuredClone(pMachine);\n\n  if (lMachine.transitions && pPseudoStateNames.length > 0) {\n    lMachine.transitions = fuseTransitions(\n      lMachine.transitions,\n      pPseudoStateNames,\n      pOutgoingTransitionMap,\n      pCounter,\n    );\n  }\n\n  lMachine.states = lMachine.states.map((pState) =>\n    pState.statemachine\n      ? {\n          ...pState,\n          statemachine: deSugarPseudoStates(\n            pState.statemachine,\n            pPseudoStateNames,\n            pOutgoingTransitionMap,\n            pCounter,\n          ),\n        }\n      : pState,\n  );\n\n  return lMachine;\n}\n\nfunction removeStatesCascading(\n  pMachine: IStateMachine,\n  pStateNames: string[],\n): IStateMachine {\n  const lMachine = structuredClone(pMachine);\n\n  if (lMachine.transitions) {\n    lMachine.transitions = lMachine.transitions.filter(\n      (pTransition) =>\n        !pStateNames.some(\n          (pJunctionStateName) =>\n            pJunctionStateName === pTransition.from ||\n            pJunctionStateName === pTransition.to,\n        ),\n    );\n  }\n\n  lMachine.states = lMachine.states\n    .filter((pState) => !pStateNames.includes(pState.name))\n    .map((pState) =>\n      pState.statemachine\n        ? {\n            ...pState,\n            statemachine: removeStatesCascading(\n              pState.statemachine,\n              pStateNames,\n            ),\n          }\n        : pState,\n    );\n  return lMachine;\n}\n\n/**\n * Takes a state machine and replaces all forks with transitions from its\n * respective inputs and outputs\n *\n * e.g.\n * ```smcat\n * a => ];\n * b => ];\n * ] => c;\n * ] => d;\n * ```\n *\n * will become\n * ```smcat\n * a => c;\n * a => d;\n * b => c;\n * b => d;\n * ```\n */\nfunction desugar(\n  pMachine: IStateMachine,\n  pDesugarableStates: StateType[] = [\"fork\", \"junction\", \"choice\"],\n): IStateMachine {\n  const lModel = new StateMachineModel(pMachine);\n\n  const lPseudoStateNames = lModel\n    .findStatesByTypes(pDesugarableStates)\n    .map(({ name }) => name);\n\n  const lOutgoingTransitionMap: ITransitionMap = lPseudoStateNames.reduce(\n    (pAll, pStateName) => {\n      pAll[pStateName] = lModel.findTransitionsByFrom(pStateName);\n      return pAll;\n    },\n    {},\n  );\n  const lMaximumTransitionId = lModel.getMaximumTransitionId();\n\n  const lMachine = deSugarPseudoStates(\n    pMachine,\n    lPseudoStateNames,\n    lOutgoingTransitionMap,\n    new Counter(lMaximumTransitionId),\n  );\n\n  return removeStatesCascading(lMachine, lPseudoStateNames);\n}\n\nexport default desugar;\n"],
  "mappings": "oJAcA,SAASA,EACPC,EACAC,EACAC,EACQ,CACR,OAAOF,EACH,GAAGA,CAAc,GAAGE,CAAS,GAAGD,CAAc,GAC9CA,CACN,CAEA,SAASE,EACPC,EACAC,EACAC,EACa,CAUb,IAAMC,EAAe,CACnB,GAAGH,EACH,GAAGC,EACH,KAAMD,EAAoB,KAC1B,GAAIC,EAAoB,GACxB,GAAIC,EAAS,KAAK,CACpB,EAEA,OAAID,EAAoB,SACtBE,EAAa,OAASR,EACpBK,EAAoB,OACpBC,EAAoB,OACpB;AAAA,CACF,IAEEE,EAAa,OAASA,EAAa,MAAQA,EAAa,UAC1DA,EAAa,MAAQC,EACnBD,EAAa,MACbA,EAAa,KACbA,EAAa,MACf,GAGKA,CACT,CAGA,SAASE,EACPC,EACAC,EACAC,EACAN,EACe,CACf,IAAMO,EAAyB,CAAC,EAEhC,QAAWC,KAAeJ,EAAc,CACtC,IAAIK,EAAS,GACb,QAAWC,KAAcL,EACvB,GAAIK,IAAeF,EAAY,IAAMF,EAAuBI,CAAU,EAAG,CAEvE,QAAWC,KAAaL,EAAuBI,CAAU,EACvDH,EAAQ,KACNV,EAAuBW,EAAaG,EAAWX,CAAQ,CACzD,EAEFS,EAAS,EACX,CAEGA,GACHF,EAAQ,KAAKC,CAAW,CAE5B,CAEA,OAAOD,CACT,CAEA,SAASK,EACPC,EACAR,EACAC,EACAN,EACe,CACf,IAAMc,EAAW,gBAAgBD,CAAQ,EAEzC,OAAIC,EAAS,aAAeT,EAAkB,OAAS,IACrDS,EAAS,YAAcX,EACrBW,EAAS,YACTT,EACAC,EACAN,CACF,GAGFc,EAAS,OAASA,EAAS,OAAO,IAAKC,GACrCA,EAAO,aACH,CACE,GAAGA,EACH,aAAcH,EACZG,EAAO,aACPV,EACAC,EACAN,CACF,CACF,EACAe,CACN,EAEOD,CACT,CAEA,SAASE,EACPH,EACAI,EACe,CACf,IAAMH,EAAW,gBAAgBD,CAAQ,EAEzC,OAAIC,EAAS,cACXA,EAAS,YAAcA,EAAS,YAAY,OACzCI,GACC,CAACD,EAAY,KACVE,GACCA,IAAuBD,EAAY,MACnCC,IAAuBD,EAAY,EACvC,CACJ,GAGFJ,EAAS,OAASA,EAAS,OACxB,OAAQC,GAAW,CAACE,EAAY,SAASF,EAAO,IAAI,CAAC,EACrD,IAAKA,GACJA,EAAO,aACH,CACE,GAAGA,EACH,aAAcC,EACZD,EAAO,aACPE,CACF,CACF,EACAF,CACN,EACKD,CACT,CAsBA,SAASM,EACPP,EACAQ,EAAkC,CAAC,OAAQ,WAAY,QAAQ,EAChD,CACf,IAAMC,EAAS,IAAIC,EAAkBV,CAAQ,EAEvCW,EAAoBF,EACvB,kBAAkBD,CAAkB,EACpC,IAAI,CAAC,CAAE,KAAAI,CAAK,IAAMA,CAAI,EAEnBC,EAAyCF,EAAkB,OAC/D,CAACG,EAAMC,KACLD,EAAKC,CAAU,EAAIN,EAAO,sBAAsBM,CAAU,EACnDD,GAET,CAAC,CACH,EACME,EAAuBP,EAAO,uBAAuB,EAErDR,EAAWF,EACfC,EACAW,EACAE,EACA,IAAII,EAAQD,CAAoB,CAClC,EAEA,OAAOb,EAAsBF,EAAUU,CAAiB,CAC1D,CAEA,IAAOO,EAAQX",
  "names": ["fuseTransitionAttribute", "pIncomingThing", "pOutgoingThing", "pJoinChar", "fuseIncomingToOutgoing", "pIncomingTransition", "pOutgoingTransition", "pCounter", "lReturnValue", "formatLabel", "fuseTransitions", "pTransitions", "pPseudoStateNames", "pOutgoingTransitionMap", "lResult", "lTransition", "lAdded", "lStateName", "lOutgoing", "deSugarPseudoStates", "pMachine", "lMachine", "pState", "removeStatesCascading", "pStateNames", "pTransition", "pJunctionStateName", "desugar", "pDesugarableStates", "lModel", "StateMachineModel", "lPseudoStateNames", "name", "lOutgoingTransitionMap", "pAll", "pStateName", "lMaximumTransitionId", "Counter", "desugar_default"]
}
