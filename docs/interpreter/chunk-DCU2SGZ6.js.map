{
  "version": 3,
  "sources": ["../../src/parse/parser-helpers.mts"],
  "sourcesContent": ["/* eslint-disable import/exports-last */\n/* eslint-disable security/detect-object-injection */\nimport type {\n  IState,\n  IStateMachine,\n  StateType,\n} from \"types/state-machine-cat.mjs\";\nimport StateMachineModel from \"../state-machine-model.mjs\";\n\nfunction stateExists(pKnownStateNames: string[], pName: string): boolean {\n  return pKnownStateNames.includes(pName);\n}\n\ntype RegExp2StateType = {\n  re: RegExp;\n  stateType: import(\"../../types/state-machine-cat.mjs\").StateType;\n};\n\nconst RE2STATE_TYPE: RegExp2StateType[] = [\n  {\n    re: /initial/,\n    stateType: \"initial\",\n  },\n  {\n    re: /final/,\n    stateType: \"final\",\n  },\n  {\n    re: /parallel/,\n    stateType: \"parallel\",\n  },\n  {\n    re: /(deep.*history)|(history.*deep)/,\n    stateType: \"deephistory\",\n  },\n  {\n    re: /history/,\n    stateType: \"history\",\n  },\n  {\n    re: /^\\^.*/,\n    stateType: \"choice\",\n  },\n  {\n    re: /^].*/,\n    stateType: \"forkjoin\",\n  },\n];\n\nfunction matches(pName: string) {\n  return (pEntry: RegExp2StateType): boolean => pEntry.re.test(pName);\n}\n\nexport function getStateType(pName: string): StateType {\n  return (RE2STATE_TYPE.find(matches(pName)) || { stateType: \"regular\" })\n    .stateType;\n}\n\nexport function initState(pName: string): IState {\n  return {\n    name: pName,\n    type: getStateType(pName),\n  };\n}\n\nfunction isComposite(pState: IState): boolean {\n  return Boolean(pState.statemachine);\n}\n\nfunction getAlreadyDeclaredStates(pStateMachine: IStateMachine): string[] {\n  const lStates = pStateMachine?.states ?? [];\n\n  return lStates.filter(isComposite).reduce(\n    (pAllStateNames, pThisState) =>\n      pAllStateNames.concat(\n        // cast: because of the isComposite, we now pThisState has a .statemachine\n        // attribute and it won't be undefined\n        getAlreadyDeclaredStates(pThisState.statemachine as IStateMachine),\n      ),\n    lStates.map(({ name }) => name),\n  );\n}\n\n// eslint-disable-next-line complexity\nexport function extractUndeclaredStates(\n  pStateMachine: IStateMachine,\n  pKnownStateNames: string[],\n): IState[] {\n  pKnownStateNames =\n    pKnownStateNames ?? getAlreadyDeclaredStates(pStateMachine);\n\n  pStateMachine.states = pStateMachine?.states ?? [];\n  const lTransitions = pStateMachine?.transitions ?? [];\n\n  for (const lState of pStateMachine.states.filter(isComposite)) {\n    // @ts-expect-error isComposite guarantees the statemachine attribute exists, TS doesn't understand that yet, though\n    lState.statemachine.states = extractUndeclaredStates(\n      // @ts-expect-error isComposite guarantees the statemachine attribute exists, TS doesn't understand that yet, though\n      lState.statemachine,\n      pKnownStateNames,\n    );\n  }\n\n  for (const lTransition of lTransitions) {\n    if (!stateExists(pKnownStateNames, lTransition.from)) {\n      pKnownStateNames.push(lTransition.from);\n      pStateMachine.states.push(initState(lTransition.from));\n    }\n    if (!stateExists(pKnownStateNames, lTransition.to)) {\n      pKnownStateNames.push(lTransition.to);\n      pStateMachine.states.push(initState(lTransition.to));\n    }\n  }\n  return pStateMachine.states;\n}\n\nfunction classifyForkJoin(\n  pInComingCount: number,\n  pOutGoingCount: number,\n): StateType {\n  let lReturnValue: StateType = \"junction\";\n\n  if (pInComingCount <= 1 && pOutGoingCount > 1) {\n    lReturnValue = \"fork\";\n  }\n  if (pInComingCount > 1 && pOutGoingCount <= 1) {\n    lReturnValue = \"join\";\n  }\n\n  return lReturnValue;\n}\n\nexport function classifyForkJoins(\n  pStateMachine: IStateMachine,\n  pFlattenedStateMachineModel = new StateMachineModel(pStateMachine),\n): IStateMachine {\n  // TODO: mutates parameter\n  pStateMachine.states = pStateMachine.states.map((pState) => {\n    if (pState.type === \"forkjoin\" && !pState.typeExplicitlySet) {\n      const lInComingCount = pFlattenedStateMachineModel.findTransitionsByTo(\n        pState.name,\n      ).length;\n      const lOutGoingCount = pFlattenedStateMachineModel.findTransitionsByFrom(\n        pState.name,\n      ).length;\n\n      pState.type = classifyForkJoin(lInComingCount, lOutGoingCount);\n    }\n    if (pState.statemachine) {\n      pState.statemachine = classifyForkJoins(\n        pState.statemachine,\n        pFlattenedStateMachineModel,\n      );\n    }\n    return pState;\n  });\n\n  return pStateMachine;\n}\n\nexport function stateEqual(pStateOne: IState, pStateTwo: IState): boolean {\n  return pStateOne.name === pStateTwo.name;\n}\n\nexport function uniq<SomeType>(\n  pArray: Array<SomeType>,\n  pEqualFunction: (a: SomeType, b: SomeType) => boolean,\n) {\n  return pArray.reduce((pBag: SomeType[], pMarble: SomeType) => {\n    const lMarbleIndex = pBag.findIndex((pBagItem) =>\n      pEqualFunction(pBagItem, pMarble),\n    );\n\n    if (lMarbleIndex > -1) {\n      // ensures the _last_ marble we find is in the bag on that position\n      pBag[lMarbleIndex] = pMarble;\n      return pBag;\n    }\n    return pBag.concat(pMarble);\n  }, []);\n}\n\n// to prevent ReDoS alerts in security scanners (=> as this is executed on the\n// client or the cli the risk is _very_ small), we limit the lengths of the parts\n// we capture.\nconst TRANSITION_EXPRESSION_RE =\n  // eslint-disable-next-line security/detect-unsafe-regex\n  /(?<event>[^[/]{1,256})?(?<condition>\\[[^\\]]{1,256}\\])?[^/]{0,100}(?<action>\\/.{1,2048})?/;\n\nexport function parseTransitionExpression(pString: string): {\n  event?: string;\n  cond?: string;\n  action?: string;\n} {\n  const lReturnValue: { event?: string; cond?: string; action?: string } = {};\n  const lMatch: RegExpMatchArray | null =\n    TRANSITION_EXPRESSION_RE.exec(pString);\n\n  if (lMatch?.groups) {\n    if (lMatch.groups.event) {\n      lReturnValue.event = lMatch.groups.event.trim();\n    }\n    if (lMatch.groups.condition) {\n      lReturnValue.cond = lMatch.groups.condition.slice(1, -1).trim();\n    }\n    if (lMatch.groups.action) {\n      lReturnValue.action = lMatch.groups.action\n        .slice(1, lMatch.groups.action.length)\n        .trim();\n    }\n  }\n\n  return lReturnValue;\n}\n\nexport function setIf(\n  pObject: { [name: string]: string },\n  pProperty: string,\n  pValue: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  pCondition: (pX: any) => boolean = Boolean,\n) {\n  if (pCondition(pValue)) {\n    pObject[pProperty] = pValue;\n  }\n}\n\nexport function setIfNotEmpty(\n  pObject: { [name: string]: string },\n  pProperty: string,\n  pValue: string,\n) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  setIf(pObject, pProperty, pValue, (pX: Array<any>) => pX && pX.length > 0);\n}\n\n// to prevent ReDoS alerts in security scanners (=> as this is executed on the\n// client or the cli the risk is _very_ small), we limit the lengths of the parts\n// we capture\nconst TRIGGER_RE =\n  /^(?<triggerType>entry|activity|exit)\\s{0,100}\\/\\s{0,100}(?<triggerBody>[^\\n$]{0,2048})(?:\\n|$)/;\n\nfunction extractAction(pActivityCandidate: string): {\n  type: string;\n  body: string;\n} {\n  const lReturnValue = { type: \"activity\", body: pActivityCandidate };\n  const lMatch: RegExpMatchArray | null = TRIGGER_RE.exec(pActivityCandidate);\n\n  if (lMatch?.groups) {\n    lReturnValue.type = lMatch.groups.triggerType;\n    lReturnValue.body = lMatch.groups.triggerBody;\n  }\n\n  return lReturnValue;\n}\n\nexport function extractActions(\n  pString: string,\n): { type: string; body: string }[] {\n  return pString\n    .split(/\\n\\s*/g)\n    .map((pActivityCandidate) => pActivityCandidate.trim())\n    .map(extractAction);\n}\n"],
  "mappings": "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",
  "names": ["stateExists", "pKnownStateNames", "pName", "RE2STATE_TYPE", "matches", "pEntry", "getStateType", "initState", "isComposite", "pState", "getAlreadyDeclaredStates", "pStateMachine", "lStates", "pAllStateNames", "pThisState", "name", "extractUndeclaredStates", "lTransitions", "lState", "lTransition", "classifyForkJoin", "pInComingCount", "pOutGoingCount", "lReturnValue", "classifyForkJoins", "pFlattenedStateMachineModel", "StateMachineModel", "lInComingCount", "lOutGoingCount", "stateEqual", "pStateOne", "pStateTwo", "uniq", "pArray", "pEqualFunction", "pBag", "pMarble", "lMarbleIndex", "pBagItem", "TRANSITION_EXPRESSION_RE", "parseTransitionExpression", "pString", "lMatch", "setIf", "pObject", "pProperty", "pValue", "pCondition", "setIfNotEmpty", "pX", "TRIGGER_RE", "extractAction", "pActivityCandidate", "extractActions"]
}
